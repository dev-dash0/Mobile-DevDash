package com.elfeky.devdash.ui.common.time_line_calender.model

import androidx.compose.ui.layout.Measurable
import androidx.compose.ui.layout.ParentDataModifier
import androidx.compose.ui.unit.Density
import java.time.LocalDateTime
import java.time.temporal.ChronoUnit

/**
 * Data class for holding LocalDateTime as parent data.
 */
data class LocalDateTimeData(
    val localDateTime: LocalDateTime
) : ParentDataModifier {
    override fun Density.modifyParentData(parentData: Any?) = this@LocalDateTimeData
}

/**
 * Retrieves the [LocalDateTime] associated with this [Measurable].
 *
 * This property accesses the parent data of the [Measurable] and attempts to cast it to [LocalDateTimeData].
 * If successful, it returns the LocalDateTime.
 * Throws IllegalStateException if no LocalDateTime is found.
 *
 * @throws IllegalStateException if the parent data is not of type [LocalDateTimeData] or is null.
 */
val Measurable.localDateTime: LocalDateTime
    get() = (parentData as? LocalDateTimeData)?.localDateTime
        ?: error("No LocalDateTime for measurable $this")


/**
 * Generates a sequence of [LocalDateTime] instances between this [LocalDateTime] and a [target] [LocalDateTime],
 * incrementing each step using the provided [increment] function.
 *
 * The sequence starts with the current [LocalDateTime] (the receiver). Each subsequent element in the sequence
 * is generated by applying the [increment] function to the previous element. The sequence continues as long as
 * the incremented [LocalDateTime] is before the [target] [LocalDateTime].  If the incremented time is equal to
 * or after the target, the sequence terminates.
 *
 * @param target The [LocalDateTime] representing the upper bound (exclusive) of the sequence.
 * @param increment A function that takes a [LocalDateTime] and returns a new [LocalDateTime] representing the next
 *                  step in the sequence. This function defines how the [LocalDateTime] should be incremented
 *                  in each step. For example you can add 1 day, 1 hour, 1 minute, etc.
 * @return A [Sequence] of [LocalDateTime] instances, starting with the receiver and ending just before reaching the [target].
 *
 * @throws IllegalArgumentException if the target is before the start date
 *
 * @sample
 * ```
 * val start = LocalDateTime.of(2023, 1, 1, 0, 0)
 * val end = LocalDateTime.of(2023, 1, 5, 0, 0)
 * val dailySequence = start.between(end) { plusDays(1) }
 * println(dailySequence.toList()) // Output: [2023-01-01T00:00, 2023-01-02T00:00, 2023-01-03T00:00, 2023-01-04T00:00]
 *
 * val hourlySequence = start.between(LocalDateTime.of(2023,1,1,5,0)) { plusHours(1) }
 * println(hourlySequence.toList()) // Output : [2023-01-01T00:00, 2023-01-01T01:00 */
fun LocalDateTime.between(
    target: LocalDateTime,
    increment: LocalDateTime.() -> LocalDateTime
): Sequence<LocalDateTime> {
    return generateSequence(
        seed = this,
        nextFunction = {
            val next = it.increment()
            if (next.isBefore(target)) next else null
        }
    )
}

/**
 * Calculates a sequence of [LocalDateTime] objects representing each day between two dates (inclusive of the start date, exclusive of the end date).
 *
 * This function extends [LocalDateTime] and is used in infix notation.
 *
 * The sequence starts from the current [LocalDateTime] object, truncated to the day, and progresses
 * by one day until it reaches, but does not include, the `target` date, also truncated to the day and with one day added to it.
 *
 * @param target The end [LocalDateTime] (exclusive) of the sequence.
 * @return A [Sequence] of [LocalDateTime] objects, each representing a day between the start and target dates.
 *
 * @throws IllegalArgumentException if the target is before the current date
 *
 * @sample
 * ```
 * val start = LocalDateTime.of(2023, 10, 26, 10, 0, 0)
 * val end = LocalDateTime.of(2023, 10, 29, 15, 0, 0)
 * val days = start.daysBetween(end).toList()
 * println(days) // Output: [2023-10-26T00:00, 2023-10-27T00:00, 2023-10-28T00:00]
 *
 * val start2 = LocalDateTime.of(2023, 10, 26, 10, 0, 0)
 * val end2 = LocalDateTime.of(2023, 10, 26, 15, 0, 0)
 * val days2 = start2.daysBetween(end2).toList()
 * println(days2) //Output: []
 * ```
 */
infix fun LocalDateTime.daysBetween(target: LocalDateTime): Sequence<LocalDateTime> {
    val start = truncatedTo(ChronoUnit.DAYS)
    val end = target.truncatedTo(ChronoUnit.DAYS).plusDays(1)
    return start.between(end) {
        plusDays(1)
    }
}